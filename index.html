<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Particle Grid Simulation</title>
    <style>
        body {
            display: flex;
            align-items: center;
            justify-content: center;
        }

        canvas {
            border: 1px solid black;
        }
    </style>
</head>

<body>
    <canvas id="particleCanvas" width="500" height="500"></canvas>

    <script>
        var CELL_COUNT = 25;
        var BOUNDS = [500, 500]
        var CELL_SIZE = [BOUNDS[0] / CELL_COUNT, BOUNDS[1] / CELL_COUNT]
        var GRID_SIZE = 30;
        var OFFSET = [90, -200]
        var PSCALE = 5;
        var MASS = 5;
        var SEARCH = 25;
        var GRAVITY = [0, 98];
        var TSCALE = 0.001;

        function HSVtoRGB(h, s, v) {
            let c = v * s;
            let hp = (h / 60) % 6;
            let x = c * (1 - Math.abs(hp % 2 - 1));
            let rgb = [0, 0, 0];

            if (0 <= hp && hp < 1) {
                rgb = [c, x, 0];
            } else if (1 <= hp && hp < 2) {
                rgb = [x, c, 0];
            } else if (2 <= hp && hp < 3) {
                rgb = [0, c, x];
            } else if (3 <= hp && hp < 4) {
                rgb = [0, x, c];
            } else if (4 <= hp && hp < 5) {
                rgb = [x, 0, c];
            } else if (5 <= hp && hp < 6) {
                rgb = [c, 0, x];
            }

            let m = v - c;
            rgb[0] += m;
            rgb[1] += m;
            rgb[2] += m;

            // Scale RGB values to the range [0, 255]
            return rgb.map(val => Math.round(val * 255));
        }

        class Particle {
            constructor(x, y, size, id, ctx) {
                this.id = -1;
                this.position = [x, y];
                this.size = size;
                this.ctx = ctx;
                this.velocity = [0.0, 0.0];
                this.id = id;
            }

            draw(draw_offset) {
                this.ctx.beginPath();
                this.ctx.arc(this.position[0] + draw_offset[0], this.position[1] + draw_offset[1], this.size / 2, 0, Math.PI * 2);

                var speed = Math.sqrt(this.velocity[0] * this.velocity[0] + this.velocity[1] * this.velocity[1])

                speed = Math.sqrt(speed) / 6

                let rgbColor = HSVtoRGB(200, Math.max(1 / speed, 0.01), Math.max(speed, 0.7));

                this.ctx.fillStyle = `rgb(${rgbColor[0]}, ${rgbColor[1]}, ${rgbColor[2]})`;
                this.ctx.strokeStyle = "black"
                this.ctx.fill();
                this.ctx.stroke();
            }
        }

        document.addEventListener('DOMContentLoaded', function () {
            const canvas = document.getElementById('particleCanvas');
            const ctx = canvas.getContext('2d');

            let particles = new Array(GRID_SIZE).fill(null).map(() => new Array(GRID_SIZE).fill(null));
            let cells = new Array(CELL_COUNT + 2).fill(2).map(() => new Array(CELL_COUNT + 2).fill(2));

            var id = 0;

            for (let o = 0; o < GRID_SIZE; o++) {
                for (let p = 0; p < GRID_SIZE; p++) {

                    particles[o][p] = new Particle(
                        (o + 0.5) * PSCALE + OFFSET[0],
                        (p + 0.5) * PSCALE + canvas.height - (PSCALE * GRID_SIZE) + OFFSET[1],
                        PSCALE,
                        id,
                        ctx
                    );
                    id += 1;
                }
            }

            function update() {
                calc_forces()
                advect()
            }

            function drawGrid() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                var draw_offset = [(500 - BOUNDS[0]) / 2, (500 - BOUNDS[1]) / 2]

                for (let i = 0; i < cells.length; i += 1) {
                    for (let j = 0; j < cells[0].length; j += 1) {
                        ctx.beginPath();
                        ctx.strokeStyle = "black"
                        ctx.strokeRect(i * CELL_SIZE[0] + draw_offset[0], j * CELL_SIZE[1] + draw_offset[1], CELL_SIZE[0], CELL_SIZE[1]);
                        ctx.stroke();
                    }
                }

                particles.forEach(row => {
                    row.forEach(particle => {
                        particle.draw(draw_offset);
                    });
                });

            }

            function calc_forces() {
                particles.forEach(row => {
                    row.forEach(particle => {
                        particle.velocity[0] += GRAVITY[0] * TSCALE
                        particle.velocity[1] += GRAVITY[1] * TSCALE
                    });
                });
            }

            function advect() {
                last = particles

                particles.forEach(row => {
                    row.forEach(particle => {
                        let collided = false; // Flag to track if particle has collided with another

                        // Loop through all particles to check for collisions

                        // https://codepen.io/Full_of_Symmetries/pen/qqazdW?editors=0010
                        last.forEach(row => {
                            row.forEach(other => {
                                if (other != particle) { // Avoid self-collision
                                    // Calculate squared distance between particles
                                    let dx = other.position[0] - particle.position[0];
                                    let dy = other.position[1] - particle.position[1];
                                    let distSq = dx * dx + dy * dy;

                                    // Calculate the sum of the radii squared
                                    let sumRadiiSq = (particle.size / 2) * (particle.size / 2) + (other.size / 2) * (other.size / 2);

                                    // Check if squared distance is less than the sum of the radii squared (collision)
                                    if (distSq < sumRadiiSq) {
                                        // Handle collision
                                        var vel_diff = [particle.velocity[0] - other.velocity[0], particle.velocity[1] - other.velocity[1]]
                                        
                                        if (vel_diff[0] * (other.position[0] - particle.position[0]) + vel_diff[1] * (other.position[1] - particle.position[1]) >= 0) {
                                            var theta = -Math.atan2(other.position[1] - particle.position[1], other.position[0] - particle.position[0])
                                            var v1 = rotate(particle.velocity, theta)
                                            var v2 = rotate(other.velocity, theta)

                                            var u1 = rotate([v1[0] + v2[0], v1[1]], -theta);
                                            var u2 = rotate([v2[0] + v1[0], v2[1]], -theta);

                                            particle.velocity[0] = u1[0]
                                            particle.velocity[1] = u1[1]
                                            other.velocity[0] = u2[0]
                                            other.velocity[1] = u2[1]
                                        }
                                    }
                                }
                            });
                        });

                        // If no collision occurred, proceed with advection
                        // Advect particle
                        let advect = [
                            particle.position[0] + particle.velocity[0] * TSCALE,
                            particle.position[1] + particle.velocity[1] * TSCALE
                        ];

                        // Check if particle is within bounds
                        if (advect[0] >= 0 && advect[0] < BOUNDS[0] && advect[1] >= 0 && advect[1] < BOUNDS[1]) {
                            particle.position = advect;
                        } else {
                            if (advect[0] < 0) {
                                particle.velocity[0] *= -1
                                particle.position[0] = 0
                            }
                            if (advect[0] > BOUNDS[0]) {
                                particle.velocity[0] *= -1
                                particle.position[0] = BOUNDS[0]
                            }
                            if (advect[1] < 0) {
                                particle.velocity[1] *= -1
                                particle.position[1] = 0
                            }
                            if (advect[1] > BOUNDS[1]) {
                                particle.velocity[1] *= -1
                                particle.position[1] = BOUNDS[1]
                            }
                        }
                    });
                });
            }

            function rotate(v, theta) {
                return [v[0] * Math.cos(theta) - v[1] * Math.sin(theta), v[0] * Math.sin(theta) + v[1] * Math.cos(theta)];
            }

            function hashCoords(i, j) {
                var h = (i * 92837111) ^ (j * 689287499)
                return Math.abs(h)
            }

            function animate() {
                update();
                drawGrid();
                requestAnimationFrame(animate);
            }

            animate();
        });

    </script>
</body>