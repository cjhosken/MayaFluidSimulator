<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Particle Grid Simulation</title>
    <style>
        body {
            display: flex;
            align-items: center;
            justify-content: center;
        }

        canvas {
            border: 1px solid black;
        }
    </style>
</head>

<body>
    <canvas id="particleCanvas" width="600" height="600"></canvas>

    <script>
        var CELL_COUNT = 25;
        var BOUNDS = [500, 500]
        var CELL_SIZE = [BOUNDS[0] / CELL_COUNT, BOUNDS[1] / CELL_COUNT]
        var GRID_SIZE = 20;
        var OFFSET = [90, -200]
        var PSCALE = 10;
        var MASS = 5;
        var SEARCH = 25;
        var KFAC = 200000;
        var DENSITY = 998.2
        var GRAVITY = [0, 98];
        var TSCALE = 0.1;
        var VISCFAC = 5000000;
        var FLOOR_DAMP = 0.0
        var SMOOTHING_FAC = 0.1
        var TOTAL_DENSITY = 0

        function HSVtoRGB(h, s, v) {
            let c = v * s;
            let hp = (h / 60) % 6;
            let x = c * (1 - Math.abs(hp % 2 - 1));
            let rgb = [0, 0, 0];

            if (0 <= hp && hp < 1) {
                rgb = [c, x, 0];
            } else if (1 <= hp && hp < 2) {
                rgb = [x, c, 0];
            } else if (2 <= hp && hp < 3) {
                rgb = [0, c, x];
            } else if (3 <= hp && hp < 4) {
                rgb = [0, x, c];
            } else if (4 <= hp && hp < 5) {
                rgb = [x, 0, c];
            } else if (5 <= hp && hp < 6) {
                rgb = [c, 0, x];
            }

            let m = v - c;
            rgb[0] += m;
            rgb[1] += m;
            rgb[2] += m;

            // Scale RGB values to the range [0, 255]
            return rgb.map(val => Math.round(val * 255));
        }

        class Particle {
            constructor(x, y, size, id, ctx) {
                this.id = -1;
                this.position = [x, y];
                this.size = size;
                this.ctx = ctx;
                this.velocity = [0.0, 0.0];
                this.id = id;
            }

            draw(draw_offset) {
                this.ctx.beginPath();
                this.ctx.arc(this.position[0] + draw_offset[0], this.position[1] + draw_offset[1], this.size / 2, 0, Math.PI * 2);

                var speed = Math.sqrt(this.velocity[0] * this.velocity[0] + this.velocity[1] * this.velocity[1])

                speed = Math.sqrt(speed) / 6

                let rgbColor = HSVtoRGB(200, Math.max(1 / speed, 0.01), Math.max(speed, 0.7));

                this.ctx.fillStyle = `rgb(${rgbColor[0]}, ${rgbColor[1]}, ${rgbColor[2]})`;
                this.ctx.strokeStyle = "black"
                this.ctx.fill();
                this.ctx.stroke();
            }
        }

        document.addEventListener('DOMContentLoaded', function () {
            const canvas = document.getElementById('particleCanvas');
            const ctx = canvas.getContext('2d');

            let particles = new Array(GRID_SIZE).fill(null).map(() => new Array(GRID_SIZE).fill(null));
            let velocity_u = new Array(CELL_COUNT + 1).fill(0).map(() => new Array(CELL_COUNT).fill(0));
            let velocity_v = new Array(CELL_COUNT).fill(0).map(() => new Array(CELL_COUNT + 1).fill(0));
            let type = new Array(CELL_COUNT + 2).fill(2).map(() => new Array(CELL_COUNT + 2).fill(2));
            let density = new Array(CELL_COUNT).fill(2).map(() => new Array(CELL_COUNT).fill(2));

            var id = 0;

            for (let o = 0; o < GRID_SIZE; o++) {
                for (let p = 0; p < GRID_SIZE; p++) {

                    particles[o][p] = new Particle(
                        (o + 0.5) * PSCALE + OFFSET[0],
                        (p + 0.5) * PSCALE + canvas.height - (PSCALE * GRID_SIZE) + OFFSET[1],
                        PSCALE,
                        id,
                        ctx
                    );
                    id += 1;
                }
            }

            function update() {
                to_grid()
                calc_forces()
                boundary_conditions()
                solve_divergence()
                from_grid()
            }

            function drawGrid() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                var draw_offset = [(600 - BOUNDS[0]) / 2, (600 - BOUNDS[1]) / 2 ]

                if (true) {
                    for (let i = -1; i <= CELL_COUNT; i += 1) {
                        for (let j = -1; j <= CELL_COUNT; j += 1) {
                            ctx.beginPath();
                            ctx.strokeStyle = "black"
                            ctx.fillStyle = "black"
                            if (type[i+1][j+1] == 2) { ctx.fillRect(i * CELL_SIZE[0] + draw_offset[0], j * CELL_SIZE[1] + draw_offset[1], CELL_SIZE[0], CELL_SIZE[1]); }
                            ctx.fillStyle = "blue"
                            if (type[i+1][j+1] == 1) { ctx.fillRect(i * CELL_SIZE[0] + draw_offset[0], j * CELL_SIZE[1] + draw_offset[1], CELL_SIZE[0], CELL_SIZE[1]); }
                            if (type[i+1][j+1] == 0) { ctx.strokeRect(i * CELL_SIZE[0] + draw_offset[0], j * CELL_SIZE[1] + draw_offset[1], CELL_SIZE[0], CELL_SIZE[1]); }
                            ctx.stroke();
                        }
                    }
                }

                if (false) {
                    // Draw horizontal lines
                    for (let ux = 0; ux < velocity_u.length; ux += 1) {
                        for (let uy = velocity_u[0].length - 1; uy >= 0; uy -= 1) {
                            ctx.beginPath();
                            ctx.arc((ux) * CELL_SIZE[0]  + draw_offset[0], (uy + 0.5) * CELL_SIZE[1]  + draw_offset[1], Math.sqrt(velocity_u[ux][uy]), 0, Math.PI * 2);
                            ctx.fillStyle = "red"
                            ctx.fill();
                            ctx.stroke();
                        }
                    }

                    // Draw horizontal lines
                    for (let vx = 0; vx < velocity_v.length; vx += 1) {
                        for (let vy = velocity_v[0].length - 1; vy >= 0; vy -= 1) {
                            ctx.beginPath();
                            ctx.arc((vx + 0.5) * CELL_SIZE[0] + draw_offset[0], (vy) * CELL_SIZE[1] + draw_offset[1], Math.sqrt(velocity_v[vx][vy]), 0, Math.PI * 2);
                            ctx.fillStyle = "green"
                            ctx.fill();
                            ctx.stroke();
                        }
                    }
                }

                particles.forEach(row => {
                    row.forEach(particle => {
                        particle.draw(draw_offset);
                    });
                });

            }

            function to_grid() {
                let weight_u = new Array((BOUNDS[0] / CELL_SIZE[0]) + 1).fill(0).map(() => new Array((BOUNDS[1] / CELL_SIZE[1])).fill(0));
                let weight_v = new Array((BOUNDS[0] / CELL_SIZE[0])).fill(0).map(() => new Array((BOUNDS[1] / CELL_SIZE[1]) + 1).fill(0));


                particles.forEach(row => {
                    row.forEach(particle => {
                        i = Math.floor(particle.position[0] / CELL_SIZE[0])
                        j = Math.floor(particle.position[1] / CELL_SIZE[1])
                        
                        if (is_not_border(i, j)) {
                            type[i+1][j+1] = 1
                        }

                        x = particle.position[0] / CELL_SIZE[0]
                        y = particle.position[1] / CELL_SIZE[1] - 0.5

                        i = Math.floor(x)
                        j = Math.floor(y)

                        dx = x - i
                        dy = y - j

                        b00 = is_not_border(i, j)
                        b10 = is_not_border(i+1, j)
                        b01 = is_not_border(i, j+1)
                        b11 = is_not_border(i+1, j+1)

                        w00 = (1 - dx) * (1 - dy) * b00
                        w10 = (dx) * (1 - dy) * b10
                        w01 = (1 - dx) * (dy) * b01
                        w11 = (dx) * (dy) * b11

                        if (w00) {
                            velocity_u[i][j] += w00 * particle.velocity[0]
                            weight_u[i][j] += w00
                        }
                        if (w10) {
                            velocity_u[i + 1][j] += w10 * particle.velocity[0]
                            weight_u[i + 1][j] += w10
                        }
                        if (w01) {
                            velocity_u[i][j + 1] += w01 * particle.velocity[0]
                            weight_u[i][j + 1] += w01
                        }
                        if (w11) {
                            velocity_u[i + 1][j + 1] += w11 * particle.velocity[0]
                            weight_u[i + 1][j + 1] += w11
                        }

                        x = particle.position[0] / CELL_SIZE[0] - 0.5
                        y = particle.position[1] / CELL_SIZE[1]

                        dx = x - i
                        dy = y - j

                        b00 = is_not_border(i, j)
                        b10 = is_not_border(i+1, j)
                        b01 = is_not_border(i, j+1)
                        b11 = is_not_border(i+1, j+1)


                        w00 = (1 - dx) * (1 - dy) * b00
                        w10 = (dx) * (1 - dy) * b10
                        w01 = (1 - dx) * (dy) * b01
                        w11 = (dx) * (dy) * b11


                        if (w00) {
                            velocity_v[i][j] += w00 * particle.velocity[1]
                            weight_v[i][j] += w00
                        }
                        if (w10) {
                            velocity_v[i + 1][j] += w10 * particle.velocity[1]
                            weight_v[i + 1][j] += w10
                        }
                        if (w01) {
                            velocity_v[i][j + 1] += w01 * particle.velocity[1]
                            weight_v[i][j + 1] += w01
                        }
                        if (w11) {
                            velocity_v[i + 1][j + 1] += w11 * particle.velocity[1]
                            weight_v[i + 1][j + 1] += w11
                        }

                        x = particle.position[0] / CELL_SIZE[0] + 0.5
                        y = particle.position[1] / CELL_SIZE[1] + 0.5

                        i = Math.floor(x)
                        j = Math.floor(y)

                        dx = x - i
                        dy = y - j

                        b00 = is_not_border(i, j)
                        b10 = is_not_border(i+1, j)
                        b01 = is_not_border(i, j+1)
                        b11 = is_not_border(i+1, j+1)

                        w00 = (1 - dx) * (1 - dy) * b00
                        w10 = (dx) * (1 - dy) * b10
                        w01 = (1 - dx) * (dy) * b01
                        w11 = (dx) * (dy) * b11

                        total_weight = w00 + w10 + w01 + w11

                        if (total_weight > 0) {
                            w00 /= total_weight 
                            w10 /= total_weight 
                            w01 /= total_weight 
                            w11 /= total_weight
                        }
                        
                        if (w00) {
                            density[i][j] += w00 
                        }
                        if (w10) {
                            density[i + 1][j] += w10
                        }
                        if (w01) {
                            density[i][j + 1] += w01 
                        }
                        if (w11) {
                            density[i + 1][j + 1] += w11
                        }
                    })
                })

                for (let ux = 0; ux < velocity_u.length; ux++) {
                    for (let uy = 0; uy < velocity_u[0].length; uy++) {
                        if (weight_u[ux][uy] > 0) {
                            velocity_u[ux][uy] /= weight_u[ux][uy]
                        }
                    }
                }

                for (let vx = 0; vx < velocity_v.length; vx++) {
                    for (let vy = 0; vy < velocity_v[0].length; vy++) {
                        if (weight_v[vx][vy] > 0) {
                            velocity_v[vx][vy] /= weight_v[vx][vy]
                        }
                    }
                }

                count = 0
                total = 0

                for (let i = 0; i < density.length; i++) {
                    for (let j = 0; j < density[0].length; j++) {
                        if (density[i][j] > 0) {
                            count += 1
                            total += density[i][j]
                        }
                    }  
                }

                if (count > 0) TOTAL_DENSITY = total / count
                
                
            }

            function is_not_border(i, j) {
                return (
                    0 <= i <= CELL_COUNT &&
                    0 <= j <= CELL_COUNT
                ) && (
                    type[Math.max(0, Math.min(i+1, type.length-1))][Math.max(Math.min(j+1, type[0].length-1), 0)] != 2
                )
            }

            function calc_forces() {
                for (let ux = 0; ux < velocity_u.length; ux++) {
                    for (let uy = 0; uy < velocity_u[0].length; uy++) {
                        velocity_u[ux][uy] += GRAVITY[0] * TSCALE
                    }
                }

                for (let vx = 0; vx < velocity_v.length; vx++) {
                    for (let vy = 0; vy < velocity_v[0].length; vy++) {
                        velocity_v[vx][vy] += GRAVITY[1] * TSCALE
                    }
                }
            }

            function boundary_conditions() {
                for (let uy = 0; uy < velocity_u[0].length; uy++) {
                    if (velocity_u[0][uy] < 0) velocity_u[0][uy] = 0
                    if (velocity_u[velocity_u.length - 1][uy] > 0) velocity_u[velocity_u.length - 1][uy] = 0
                }

                for (let vx = 0; vx < velocity_v.length; vx++) {
                    if (velocity_v[vx][0] < 0) velocity_v[vx][0] = 0
                    if (velocity_v[vx][velocity_v[0].length - 1] > 0) velocity_v[vx][velocity_v[0].length] = 0
                }
            }

            function solve_divergence() {
                let divergence = new Array((BOUNDS[0] / CELL_SIZE[0])).fill(0).map(() => new Array((BOUNDS[1] / CELL_SIZE[1])).fill(0));
                let borders = new Array((BOUNDS[0] / CELL_SIZE[0])).fill(0).map(() => new Array((BOUNDS[1] / CELL_SIZE[1])).fill(0));

                for (let n = 0; n < 5; n++) {
                    for (let i = 0; i < CELL_COUNT; i++) {
                        for (let j = 0; j < CELL_COUNT; j++) {
                           
                            divergence[i][j] = (
                                (velocity_u[i + 1][j] - velocity_u[i][j]) / CELL_SIZE[0] +
                                (velocity_v[i][j + 1] - velocity_v[i][j]) / CELL_SIZE[1]
                            ) * 1 - 1 * (density[i][j] - 10)

                            if (is_not_border(i, j)) {
                                borders[i][j] = (
                                is_not_border(i-1, j) +
                                is_not_border(i+1, j) +
                                is_not_border(i, j-1) +
                                is_not_border(i, j+1) 
                            )}
                        }
                    }
                    for (let i = 0; i < CELL_COUNT; i++) {
                        for (let j = 0; j < CELL_COUNT; j++) {
                            if (is_not_border(i, j)) {
                                velocity_u[i][j] += divergence[i][j] * (is_not_border(i - 1, j)) / borders[i][j]
                                velocity_u[i + 1][j] -= divergence[i][j] * (is_not_border(i + 1, j)) / borders[i][j]

                                velocity_v[i][j] += divergence[i][j] * (is_not_border(i, j - 1)) / borders[i][j]
                                velocity_v[i][j + 1] -= divergence[i][j] * (is_not_border(i, j + 1)) / borders[i][j]
                            }
                        }
                    }
                }
            }

            function from_grid() {
                particles.forEach(row => {
                    row.forEach(particle => {
                        x = particle.position[0] / CELL_SIZE[0]
                        y = particle.position[1] / CELL_SIZE[1] - 0.5

                        i = Math.floor(x)
                        j = Math.floor(y)

                        dx = x - i
                        dy = y - j

                        b00 = is_not_border(i, j)
                        b10 = is_not_border(i+1, j)
                        b01 = is_not_border(i, j+1)
                        b11 = is_not_border(i+1, j+1)

                        w00 = (1 - dx) * (1 - dy) * b00
                        w10 = (dx) * (1 - dy) * b10
                        w01 = (1 - dx) * (dy) * b01
                        w11 = (dx) * (dy) * b11

                        total_weight = w00 + w10 + w01 + w11

                        var vel_u = 0
                        if (w00) vel_u += velocity_u[i][j] * w00
                        if (w10) vel_u += velocity_u[i+1][j] * w10
                        if (w01) vel_u += velocity_u[i][j+1] * w01
                        if (w11) vel_u += velocity_u[i+1][j+1] * w11


                        if (total_weight > 0) vel_u /= total_weight

                        x = particle.position[0] / CELL_SIZE[0] - 0.5
                        y = particle.position[1] / CELL_SIZE[1]

                        i = Math.floor(x)
                        j = Math.floor(y)

                        dx = x - i
                        dy = y - j

                        b00 = is_not_border(i, j)
                        b10 = is_not_border(i+1, j)
                        b01 = is_not_border(i, j+1)
                        b11 = is_not_border(i+1, j+1)

                        w00 = (1 - dx) * (1 - dy) * b00
                        w10 = (dx) * (1 - dy) * b10
                        w01 = (1 - dx) * (dy) * b01
                        w11 = (dx) * (dy) * b11

                        total_weight = w00 + w10 + w01 + w11

                        var vel_v = 0
                        if (w00) vel_v += velocity_v[i][j] * w00
                        if (w10) vel_v += velocity_v[i+1][j] * w10
                        if (w01) vel_v += velocity_v[i][j+1] * w01
                        if (w11) vel_v += velocity_v[i+1][j+1] * w11

                        if (total_weight > 0) vel_v /= total_weight


                        particle.velocity = [vel_u, vel_v]

                        var advected = [
                            particle.position[0] + particle.velocity[0] * TSCALE,
                            particle.position[1] + particle.velocity[1] * TSCALE
                        ]
                        var o = Math.floor(advected[0] / CELL_SIZE[0])
                        var p = Math.floor(advected[1] / CELL_SIZE[1])

                        if (!is_not_border(o, p)) {
                            ni = Math.sqrt(particle.velocity[0] * particle.velocity[0] + particle.velocity[1] * particle.velocity[1])

                            normal = [0, 0]

                            if (i < 0) {
                                normal[0] = 1
                            }

                            if (j < 0) {
                                normal[1] = 1
                            }

                            if (i >= CELL_COUNT) {
                                normal[0] = -1
                            }

                            if (j >= CELL_COUNT) {
                                normal[1] = -1
                            }

                            nj = Math.sqrt([0] * normal[0] + normal[1] * normal[1]) 
                            // r = d - 2(d . n)n

                            norm = normal
                            vel = [
                                particle.velocity[0],
                                particle.velocity[1]
                            ]

                            angle = dot(vel, norm)


                            particle.velocity[0] = -2 * angle * norm[0]
                            particle.velocity[1] = -2 * angle * norm[1]
                            
                        }  else {
                            particle.position[0] += particle.velocity[0] * TSCALE
                            particle.position[1] += particle.velocity[1] * TSCALE
                        }

                    });
                });
            }

            function dot(i, j) {
                return i[0] * j[0] + i[1] * j[1]
            }

            function animate() {
                clear();
                update();
                drawGrid();
                requestAnimationFrame(animate);
            }

            function clear() {
                for (let i = 0; i < CELL_COUNT; i++) {
                    for (let j = 0; j < CELL_COUNT; j++) {
                        type[i+1][j+1] = 0
                    }
                }

                velocity_u = new Array((BOUNDS[0] / CELL_SIZE[0]) + 1).fill(0).map(() => new Array((BOUNDS[1] / CELL_SIZE[1])).fill(0));
                velocity_v = new Array((BOUNDS[0] / CELL_SIZE[0])).fill(0).map(() => new Array((BOUNDS[1] / CELL_SIZE[1] + 1)).fill(0));
                density = new Array((BOUNDS[0] / CELL_SIZE[0])).fill(2).map(() => new Array((BOUNDS[1] / CELL_SIZE[1])).fill(2));
            }



            animate();
        });

    </script>
</body>
