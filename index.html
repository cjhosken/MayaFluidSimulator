<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Particle Grid Simulation</title>
    <style>
        body {
            display: flex;
            align-items: center;
            justify-content: center;
        }

        canvas {
            border: 1px solid black;
        }
    </style>
</head>

<body>
    <canvas id="particleCanvas" width="500" height="500"></canvas>

    <script>
        var CELL_COUNT = 50;
        var BOUNDS = [500, 500]
        var CELL_SIZE = [BOUNDS[0] / CELL_COUNT, BOUNDS[1] / CELL_COUNT]
        var GRID_SIZE = 25;
        var OFFSET = [0, 0]
        var PSCALE = 5;
        var EXTERNAL = [0, -9.8];

        function HSVtoRGB(h, s, v) {
            let c = v * s;
            let hp = (h / 60) % 6;
            let x = c * (1 - Math.abs(hp % 2 - 1));
            let rgb = [0, 0, 0];

            if (0 <= hp && hp < 1) {
                rgb = [c, x, 0];
            } else if (1 <= hp && hp < 2) {
                rgb = [x, c, 0];
            } else if (2 <= hp && hp < 3) {
                rgb = [0, c, x];
            } else if (3 <= hp && hp < 4) {
                rgb = [0, x, c];
            } else if (4 <= hp && hp < 5) {
                rgb = [x, 0, c];
            } else if (5 <= hp && hp < 6) {
                rgb = [c, 0, x];
            }

            let m = v - c;
            rgb[0] += m;
            rgb[1] += m;
            rgb[2] += m;

            // Scale RGB values to the range [0, 255]
            return rgb.map(val => Math.round(val * 255));
        }

        class Particle {
            constructor(x, y, radius) {
                this.position = [x, y];
                this.velocity = [0.0, 0.0];
                this.radius = radius;
            }

            draw(ctx, draw_offset) {
                ctx.beginPath();
                ctx.arc(this.position[0] + draw_offset[0], BOUNDS[1] - this.position[1], this.radius, 0, Math.PI * 2);

                var speed = Math.sqrt(this.velocity[0] * this.velocity[0] + this.velocity[1] * this.velocity[1])

                speed = Math.sqrt(speed) / 6

                let rgbColor = HSVtoRGB(200, Math.max(1 / speed, 0.01), Math.max(speed, 0.7));

                ctx.fillStyle = `rgb(${rgbColor[0]}, ${rgbColor[1]}, ${rgbColor[2]})`;
                ctx.strokeStyle = "black"
                ctx.fill();
                ctx.stroke();
            }
        }

        document.addEventListener('DOMContentLoaded', function () {
            const canvas = document.getElementById('particleCanvas');
            const ctx = canvas.getContext('2d');

            let particles = new Array(GRID_SIZE * GRID_SIZE).fill(null)
            let velocity_u = new Array(CELL_COUNT + 1).fill(0).map(() => new Array(CELL_COUNT).fill(0));
            let velocity_v = new Array(CELL_COUNT).fill(0).map(() => new Array(CELL_COUNT + 1).fill(0));

            let last_velocity_u = new Array(CELL_COUNT + 1).fill(0).map(() => new Array(CELL_COUNT).fill(0));
            let last_velocity_v = new Array(CELL_COUNT).fill(0).map(() => new Array(CELL_COUNT + 1).fill(0));

            let density = new Array(CELL_COUNT).fill(0).map(() => new Array(CELL_COUNT).fill(0));
            let type = new Array(CELL_COUNT).fill(0).map(() => new Array(CELL_COUNT).fill(0));

            var particleHashTable = {};

            for (let o = 0; o < GRID_SIZE; o++) {
                for (let p = 0; p < GRID_SIZE; p++) {
                    const index = o * GRID_SIZE + p
                    particles[index] = new Particle(
                        (o + 0.5) * (PSCALE * 2) + OFFSET[0],
                        (p + 0.5) * (PSCALE * 2) + OFFSET[1] + (PSCALE * GRID_SIZE),
                        PSCALE
                    );
                }
            }

            function update() {
                clear()
                var tscale = 0.1

                avg_density = particle_to_grid()
                dt = calc_dt(tscale)
                calc_forces(dt)
                enforce_boundaries()
                solve_divergence(avg_density)
                particle_from_grid(dt)
                handle_collisions_and_boundary(dt)
            }

            function drawGrid() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                var draw_offset = [(500 - BOUNDS[0]) / 2, (500 - BOUNDS[1]) / 2]

                if (false) {

                    for (let i = 0; i < CELL_COUNT; i += 1) {
                        for (let j = 0; j < CELL_COUNT; j += 1) {
                            ctx.beginPath();
                            ctx.strokeStyle = "black"
                            ctx.strokeRect(i * CELL_SIZE[0] + draw_offset[0], BOUNDS[1] - (j * CELL_SIZE[1] + draw_offset[1]), CELL_SIZE[0], CELL_SIZE[1]);

                            if (type[i][j] == 1) {
                                ctx.fillStyle = "blue"
                                ctx.fillRect(i * CELL_SIZE[0] + draw_offset[0], BOUNDS[1] - (j * CELL_SIZE[1] + draw_offset[1]), CELL_SIZE[0], CELL_SIZE[1]);
                            }
                            ctx.stroke();

                            if (false) {
                            
                    

                            ctx.beginPath();
                            ctx.arc((i + 0.5) * CELL_SIZE[0] + draw_offset[0], BOUNDS[1] - ((j + 0.5) * CELL_SIZE[1] + draw_offset[1]), density[i][j] * 10, 0, Math.PI * 2);
                            ctx.fillStyle = "green"
                            ctx.fill();
                            ctx.stroke();
                            }
                        }
                    }
                }

                if (false) {

                    for (let ux = 0; ux < velocity_u.length; ux += 1) {
                        for (let uy = velocity_u[0].length - 1; uy >= 0; uy -= 1) {
                            ctx.beginPath();
                            ctx.arc((ux) * CELL_SIZE[0] + draw_offset[0], BOUNDS[1] - ((uy + 0.5) * CELL_SIZE[1] + draw_offset[1]), Math.abs(velocity_u[ux][uy]) * 0.5, 0, Math.PI * 2);
                            ctx.fillStyle = "red"
                            ctx.fill();
                            ctx.stroke();
                        }
                    }

                    // Draw horizontal lines
                    for (let vx = 0; vx < velocity_v.length; vx += 1) {
                        for (let vy = velocity_v[0].length - 1; vy >= 0; vy -= 1) {
                            ctx.beginPath();
                            ctx.arc((vx + 0.5) * CELL_SIZE[0] + draw_offset[0], BOUNDS[1] -  ((vy) * CELL_SIZE[1] + draw_offset[1]), Math.abs(velocity_v[vx][vy]) * 0.5, 0, Math.PI * 2);
                            ctx.fillStyle = "green"
                            ctx.fill();
                            ctx.stroke();
                        }
                    }
                }

                particles.forEach(particle => {
                    particle.draw(ctx, draw_offset);
                });

            }

            function particle_to_grid() {
                let weight_u = new Array(CELL_COUNT + 1).fill(0).map(() => new Array(CELL_COUNT).fill(0));
                let weight_v = new Array(CELL_COUNT).fill(0).map(() => new Array(CELL_COUNT + 1).fill(0));

                particles.forEach(particle => {
                    x = particle.position[0] / CELL_SIZE[0]
                    y = particle.position[1] / CELL_SIZE[1] - 0.5

                    i = Math.floor(x)
                    j = Math.floor(y)

                    dx = x - i
                    dy = y - j

                    b00 = in_bounds(i, j, velocity_u.length, velocity_u[0].length)
                    b10 = in_bounds(i + 1, j, velocity_u.length, velocity_u[0].length)
                    b01 = in_bounds(i, j + 1, velocity_u.length, velocity_u[0].length)
                    b11 = in_bounds(i + 1, j + 1, velocity_u.length, velocity_u[0].length)

                    w00 = (1 - dx) * (1 - dy) * b00
                    w10 = (dx) * (1 - dy) * b10
                    w01 = (1 - dx) * (dy) * b01
                    w11 = (dx) * (dy) * b11

                    i = Math.max(0, i)
                    j = Math.max(0, j)

                    velocity_u[Math.min(i, velocity_u.length - 1)][Math.min(j, velocity_u[0].length - 1)] += w00 * particle.velocity[0]
                    weight_u[Math.min(i, velocity_u.length - 1)][Math.min(j, velocity_u[0].length - 1)] += w00

                    velocity_u[Math.min(i + 1, velocity_u.length - 1)][Math.min(j, velocity_u[0].length - 1)] += w10 * particle.velocity[0]
                    weight_u[Math.min(i + 1, velocity_u.length - 1)][Math.min(j, velocity_u[0].length - 1)] += w10

                    velocity_u[Math.min(i, velocity_u.length - 1)][Math.min(j + 1, velocity_u[0].length - 1)] += w01 * particle.velocity[0]
                    weight_u[Math.min(i, velocity_u.length - 1)][Math.min(j + 1, velocity_u[0].length - 1)] += w01

                    velocity_u[Math.min(i + 1, velocity_u.length - 1)][Math.min(j + 1, velocity_u[0].length - 1)] += w11 * particle.velocity[0]
                    weight_u[Math.min(i + 1, velocity_u.length - 1)][Math.min(j + 1, velocity_u[0].length - 1)] += w11


                    x = particle.position[0] / CELL_SIZE[0] - 0.5
                    y = particle.position[1] / CELL_SIZE[1]

                    i = Math.floor(x)
                    j = Math.floor(y)

                    dx = x - i
                    dy = y - j

                    b00 = in_bounds(i, j, velocity_v.length, velocity_v[0].length)
                    b10 = in_bounds(i + 1, j, velocity_v.length, velocity_v[0].length)
                    b01 = in_bounds(i, j + 1, velocity_v.length, velocity_v[0].length)
                    b11 = in_bounds(i + 1, j + 1, velocity_v.length, velocity_v[0].length)

                    w00 = (1 - dx) * (1 - dy) * b00
                    w10 = (dx) * (1 - dy) * b10
                    w01 = (1 - dx) * (dy) * b01
                    w11 = (dx) * (dy) * b11

                    i = Math.max(0, i)
                    j = Math.max(0, j)

                    velocity_v[Math.min(i, velocity_v.length - 1)][Math.min(j, velocity_v[0].length - 1)] += w00 * particle.velocity[1]
                    weight_v[Math.min(i, velocity_v.length - 1)][Math.min(j, velocity_v[0].length - 1)] += w00

                    velocity_v[Math.min(i + 1, velocity_v.length - 1)][Math.min(j, velocity_v[0].length - 1)] += w10 * particle.velocity[1]
                    weight_v[Math.min(i + 1, velocity_v.length - 1)][Math.min(j, velocity_v[0].length - 1)] += w10

                    velocity_v[Math.min(i, velocity_v.length - 1)][Math.min(j + 1, velocity_v[0].length - 1)] += w01 * particle.velocity[1]
                    weight_v[Math.min(i, velocity_v.length - 1)][Math.min(j + 1, velocity_v[0].length - 1)] += w01

                    velocity_v[Math.min(i + 1, velocity_v.length - 1)][Math.min(j + 1, velocity_v[0].length - 1)] += w11 * particle.velocity[1]
                    weight_v[Math.min(i + 1, velocity_v.length - 1)][Math.min(j + 1, velocity_v[0].length - 1)] += w11


                    x = particle.position[0] / CELL_SIZE[0] - 0.5
                    y = particle.position[1] / CELL_SIZE[1] - 0.5

                    i = Math.floor(x)
                    j = Math.floor(y)

                    dx = x - i
                    dy = y - j

                    b00 = in_bounds(i, j, CELL_COUNT, CELL_COUNT)
                    b10 = in_bounds(i + 1, j, CELL_COUNT, CELL_COUNT)
                    b01 = in_bounds(i, j + 1, CELL_COUNT, CELL_COUNT)
                    b11 = in_bounds(i + 1, j + 1, CELL_COUNT, CELL_COUNT)

                    w00 = (1 - dx) * (1 - dy) * b00
                    w10 = (dx) * (1 - dy) * b10
                    w01 = (1 - dx) * (dy) * b01
                    w11 = (dx) * (dy) * b11

                    total_weight = w00 + w10 + w01 + w11

                    i = Math.max(0, i)
                    j = Math.max(0, j)
                    
                    density[Math.min(i, density.length - 1)][Math.min(j, density[0].length - 1)] += w00 
                    density[Math.min(i + 1, density.length - 1)][Math.min(j, density[0].length - 1)] += w10
                    density[Math.min(i, density.length - 1)][Math.min(j + 1, density[0].length - 1)] += w01
                    density[Math.min(i + 1, density.length - 1)][Math.min(j + 1, density[0].length - 1)] += w11

                    x = particle.position[0] / CELL_SIZE[0]
                    y = particle.position[1] / CELL_SIZE[1]

                    i = Math.max(Math.min(Math.floor(x), type.length - 1), 0)
                    j = Math.max(Math.min(Math.floor(y), type[0].length - 1), 0)

                    type[i][j] = 1

                })

                for (let ux = 0; ux < velocity_u.length; ux++) {
                    for (let uy = 0; uy < velocity_u[0].length; uy++) {
                        if (weight_u[ux][uy] > 0) {
                            velocity_u[ux][uy] /= weight_u[ux][uy]
                        }
                    }
                }

                for (let vx = 0; vx < velocity_v.length; vx++) {
                    for (let vy = 0; vy < velocity_v[0].length; vy++) {
                        if (weight_v[vx][vy] > 0) {
                            velocity_v[vx][vy] /= weight_v[vx][vy]
                        }
                    }
                }


                num_fluid_cells = 0
                average_density = 0

                for (let i = 0; i < CELL_COUNT; i++) {
                        for (let j = 0; j < CELL_COUNT; j++) {
                            if (density[i][j] > 0 && type[i][j] == 1) {
                                num_fluid_cells += 1
                                average_density += density[i][j]
                            }
                        }
                    }


                if (num_fluid_cells > 0) average_density /= num_fluid_cells



                last_velocity_u = velocity_u.slice()
                last_velocity_v = velocity_v.slice()

                return average_density
            }

            function in_bounds(i, j, lx, ly) {
                return (
                    0 <= i < lx &&
                    0 <= j < ly
                )
            }

            function calc_dt(tscale) {
                var max_speed = 0
                particles.forEach(particle => {
                    const speed_squared = particle.velocity[0] ** 2 + particle.velocity[1] ** 2
                    max_speed = Math.max(speed_squared, max_speed)
                })

                max_speed = Math.sqrt(max_speed)

                max_dist = Math.sqrt((CELL_SIZE[0] ** 2 + CELL_SIZE[1] ** 2) * Math.sqrt(EXTERNAL[0] ** 2 + EXTERNAL[1] ** 2))

                return Math.min(tscale, tscale * max_dist / max_speed, 1)
            }

            function calc_forces(dt) {
                TOTAL_FORCE = [
                    EXTERNAL[0],
                    EXTERNAL[1]
                ]

                for (let ux = 0; ux < velocity_u.length; ux++) {
                    for (let uy = 0; uy < velocity_u[0].length; uy++) {
                        velocity_u[ux][uy] += (EXTERNAL[0] * dt)
                    }
                }

                for (let vx = 0; vx < velocity_v.length; vx++) {
                    for (let vy = 0; vy < velocity_v[0].length; vy++) {
                        velocity_v[vx][vy] += (EXTERNAL[1] * dt)
                    }
                }
            }

            function enforce_boundaries() {
                for (let uy = 0; uy < velocity_u[0].length; uy++) {
                    if (velocity_u[0][uy] < 0) velocity_u[0][uy] = 0 
                    if (velocity_u[velocity_u.length - 1][uy] > 0) velocity_u[velocity_u.length - 1][uy] = 0
                }

                for (let vx = 0; vx < velocity_v.length; vx++) {
                    if (velocity_v[vx][0] < 0) velocity_v[vx][0]  = 0
                    if (velocity_v[vx][velocity_v[0].length - 1] > 0) velocity_v[vx][velocity_v[0].length - 1]  = 0
                }
            }

            function solve_divergence(average_density) {
                for (let n = 0; n < 5; n++) {
                    for (let i = 0; i < CELL_COUNT; i++) {
                        for (let j = 0; j < CELL_COUNT; j++) {
                            var divergence = 1.9 * (
                                (velocity_u[i + 1][j] - velocity_u[i][j]) / CELL_SIZE[0] +
                                (velocity_v[i][j + 1] - velocity_v[i][j]) / CELL_SIZE[1]
                            ) - 5 * (density[i][j] - average_density);

                            var borders = (
                                in_bounds(i - 1, j, CELL_COUNT, CELL_COUNT) +
                                in_bounds(i + 1, j, CELL_COUNT, CELL_COUNT) +
                                in_bounds(i, j - 1, CELL_COUNT, CELL_COUNT) +
                                in_bounds(i, j + 1, CELL_COUNT, CELL_COUNT)
                            )

                            velocity_u[i][j] += divergence * in_bounds(i - 1, j, CELL_COUNT, CELL_COUNT) / borders
                            velocity_u[i + 1][j] -= divergence * in_bounds(i + 1, j, CELL_COUNT, CELL_COUNT) / borders

                            velocity_v[i][j] += divergence * in_bounds(i, j - 1, CELL_COUNT, CELL_COUNT) / borders
                            velocity_v[i][j + 1] -= divergence * in_bounds(i, j + 1, CELL_COUNT, CELL_COUNT) / borders
                        }
                    }
                }
            }

            function particle_from_grid(dt) {
                // Advect particles
                particles.forEach(particle => {
                    
                    integrated_position = [particle.position[0], particle.position[1]]

                    x = integrated_position[0] / CELL_SIZE[0]
                    y = integrated_position[1] / CELL_SIZE[1] - 0.5

                    i = Math.floor(x)
                    j = Math.floor(y)

                    dx = x - i
                    dy = y - j

                    b00 = in_bounds(i, j, velocity_u.length, velocity_u[0].length)
                    b10 = in_bounds(i + 1, j, velocity_u.length, velocity_u[0].length)
                    b01 = in_bounds(i, j + 1, velocity_u.length, velocity_u[0].length)
                    b11 = in_bounds(i + 1, j + 1, velocity_u.length, velocity_u[0].length)

                    i = Math.max(0, i)
                    j = Math.max(0, j)


                    
                    w00 = (1 - dx) * (1 - dy) * (b00 && type[Math.min(i, type.length - 1)][Math.min(j, type[0].length - 1)] == 1)
                    w10 = (dx) * (1 - dy) * (b10 && type[Math.min(i+1, type.length - 1)][Math.min(j, type[0].length - 1)] == 1)
                    w01 = (1 - dx) * (dy) * (b01 && type[Math.min(i, type.length - 1)][Math.min(j+1, type[0].length - 1)] == 1)
                    w11 = (dx) * (dy) * (b11 && type[Math.min(i+1, type.length - 1)][Math.min(j+1, type[0].length - 1)] == 1)
                    
                    total_weight = w00 + w10 + w01 + w11

                    var vel_u = (
                        velocity_u[Math.min(i, velocity_u.length - 1)][Math.min(j, velocity_u[0].length - 1)] * w00 +
                        velocity_u[Math.min(i + 1, velocity_u.length - 1)][Math.min(j, velocity_u[0].length - 1)] * w10 +
                        velocity_u[Math.min(i, velocity_u.length - 1)][Math.min(j + 1, velocity_u[0].length - 1)] * w01 +
                        velocity_u[Math.min(i + 1, velocity_u.length - 1)][Math.min(j + 1, velocity_u[0].length - 1)] * w11
                    )

                    if (total_weight > 0) vel_u /= total_weight

                    x = integrated_position[0] / CELL_SIZE[0] - 0.5
                    y = integrated_position[1] / CELL_SIZE[1]

                    i = Math.floor(x)
                    j = Math.floor(y)

                    dx = x - i
                    dy = y - j

                    b00 = in_bounds(i, j, velocity_v.length, velocity_v[0].length)
                    b10 = in_bounds(i + 1, j, velocity_v.length, velocity_v[0].length)
                    b01 = in_bounds(i, j + 1, velocity_v.length, velocity_v[0].length)
                    b11 = in_bounds(i + 1, j + 1, velocity_v.length, velocity_v[0].length)

                    i = Math.max(0, i)
                    j = Math.max(0, j)

                    w00 = (1 - dx) * (1 - dy) * (b00 && type[Math.min(i, type.length - 1)][Math.min(j, type[0].length - 1)] == 1)
                    w10 = (dx) * (1 - dy) * (b10 && type[Math.min(i+1, type.length - 1)][Math.min(j, type[0].length - 1)] == 1)
                    w01 = (1 - dx) * (dy) * (b01 && type[Math.min(i, type.length - 1)][Math.min(j+1, type[0].length - 1)] == 1)
                    w11 = (dx) * (dy) * (b11 && type[Math.min(i+1, type.length - 1)][Math.min(j+1, type[0].length - 1)] == 1)

                    total_weight = w00 + w10 + w01 + w11

                    var vel_v = (
                        velocity_v[Math.min(i, velocity_v.length - 1)][Math.min(j, velocity_v[0].length - 1)] * w00 +
                        velocity_v[Math.min(i + 1, velocity_v.length - 1)][Math.min(j, velocity_v[0].length - 1)] * w10 +
                        velocity_v[Math.min(i, velocity_v.length - 1)][Math.min(j + 1, velocity_v[0].length - 1)] * w01 +
                        velocity_v[Math.min(i + 1, velocity_v.length - 1)][Math.min(j + 1, velocity_v[0].length - 1)] * w11
                    )

                    if (total_weight > 0) vel_v /= total_weight

                    particle.velocity[0] = vel_u 
                    particle.velocity[1] = vel_v

                    // Update particle position based on velocity
                    particle.position[0] += particle.velocity[0] * dt
                    particle.position[1] += particle.velocity[1] * dt

                    insertParticleIntoHashTable(particle);
                });
            }

            function handle_collisions_and_boundary(dt) {
                particles.forEach(particle => {
                    // Update particle position based on velocity
                    const x = particle.position[0];
                    const y = particle.position[1];
                    const r = particle.radius;

                    // Handle boundary conditions
                    if (x - r <= 0) {
                        particle.velocity[0] *= 0;
                        particle.position[0] = r;
                    }
                    if (x + r >= BOUNDS[0]) {
                        particle.velocity[0] *= 0;
                        particle.position[0] = BOUNDS[0] - r;
                    }
                    if (y - r <= 0) {
                        particle.velocity[1] *= 0;
                        particle.position[1] = r;
                    }
                    if (y + r >= BOUNDS[1]) {
                        particle.velocity[1] *= 0;
                        particle.position[1] = BOUNDS[1] - r;
                    }

                    var i = particle.position[0] / CELL_SIZE[0]
                    var j = particle.position[1] / CELL_SIZE[1]


                    // Push neighboring particles into the array
                    var neighboringParticles = getParticlesFromHashTable(i, j);
                    

                    // Handle particle collisions
                    neighboringParticles.forEach(other => {
                        if (particle !== other) { // Ensure we're not checking the particle against itself
                        
                            var dx = other.position[0] - particle.position[0];
                            var dy = other.position[1] - particle.position[1];
                            const dist_squared = dx * dx + dy * dy;
                            const min_dist_squared = (particle.radius + other.radius) ** 2;

                            if (dist_squared < min_dist_squared) {
                                // Swap velocities
                                const temp_velocity = particle.velocity.slice(); // Make a copy
                                particle.velocity = other.velocity.slice();
                                other.velocity = temp_velocity;

                                // Calculate the direction of the collision
                                const dist = Math.sqrt(dist_squared);
                                const overlap = (particle.radius + other.radius) - dist;

                                if (dist > 0) {
                                    dx /= dist
                                    dy /= dist
                                }

                                // Move particles apart proportionally to their overlap
                                const moveX = dx * overlap * 0.5;
                                const moveY = dy* overlap * 0.5;

                                // Move the particles in opposite directions
                                particle.position[0] -= moveX;
                                particle.position[1] -= moveY;
                                other.position[0] += moveX;
                                other.position[1] += moveY;
                            }
                        }
                    });

                    insertParticleIntoHashTable(particle);
                });
            }

            function insertParticleIntoHashTable(particle) {
                const i = particle.position[0] / CELL_SIZE[0];
                const j = particle.position[1] / CELL_SIZE[1];
                const hash = hashCoords(i, j);

                if (!particleHashTable[hash]) {
                    particleHashTable[hash] = [];
                }

                particleHashTable[hash].push(particle);
            }

            function getParticlesFromHashTable(i, j) {
                const hash = hashCoords(i, j);
                return particleHashTable[hash] || [];
            }

            function hashCoords(i, j) {
                var h = (i * 92837111) ^ (j * 689287499)
                return Math.abs(h) % (CELL_COUNT * CELL_COUNT)
            }

            function clear() {
                velocity_u = new Array(CELL_COUNT + 1).fill(0).map(() => new Array(CELL_COUNT).fill(0));
                velocity_v = new Array(CELL_COUNT).fill(0).map(() => new Array(CELL_COUNT + 1).fill(0));
                density = new Array(CELL_COUNT).fill(0).map(() => new Array(CELL_COUNT).fill(0));
                type = new Array(CELL_COUNT).fill(0).map(() => new Array(CELL_COUNT).fill(0));
            }

            function animate() {
                update();
                drawGrid();
                requestAnimationFrame(animate);
            }

            animate();
        });

    </script>
</body>